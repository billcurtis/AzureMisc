<#

Version  0.9.0

.DESCRIPTION
    This script performs a Windows Image Health Check, attempts to remediate any issues found,
    checks for and installs Windows Updates (excluding driver updates), and uploads the results
    to an Azure Storage Table for tracking and analysis.

    Key Features:
    - Uses Repair-WindowsImage to scan and repair the Windows image.
    - Utilizes native COM objects to interact with Windows Update for better compatibility.
    - Filters out driver updates while ensuring important updates (cumulative, security, .NET) are included.
    - Handles errors gracefully and provides detailed logging.
    - Uploads results to Azure Storage Table with robust error handling.

.REQUIRES
    - PowerShell 5.1 or later
    - Azure Storage Account with Table service enabled
    - Appropriate permissions to run Windows Update and Repair-WindowsImage

.NOTES

Portions generated by AI (Claude Sonnet 4).

#>

# Enforce TLS 1.2 for secure HTTPS connections to Azure Storage
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Hardcoded configuration
$UploadToStorageAccount = $true
$StorageAccountName = "<storage_account_name>"
$StorageAccountKey = "<storage_account_key>"
$TableName = "WindowsImageHealth"

# Initialize error handling for constrained environments
$ErrorActionPreference = "Continue"

# Initialize logging
$LogPath = "C:\temp"
$LogFile = Join-Path $LogPath "WindowsHealthCheck-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"

# Create log directory if it doesn't exist
if (-not (Test-Path $LogPath)) {
    try {
        New-Item -Path $LogPath -ItemType Directory -Force | Out-Null
        Write-Output "Created log directory: $LogPath"
    }
    catch {
        Write-Output "Warning: Failed to create log directory: $($_.Exception.Message)"
        $LogFile = $null  # Disable logging if we can't create the directory
    }
}

# Logging function
function Write-Log {
    param(
        [string]$Message,
        [ValidateSet("INFO", "WARNING", "ERROR", "DEBUG")]
        [string]$Level = "INFO"
    )
    
    if ($null -ne $LogFile) {
        try {
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $computerName = if ($env:COMPUTERNAME) { $env:COMPUTERNAME } else { "Unknown" }
            $logEntry = "[$timestamp] [$computerName] [$Level] $Message"
            
            # Write to log file
            Add-Content -Path $LogFile -Value $logEntry -ErrorAction SilentlyContinue
            
            # Also write to console for immediate visibility
            Write-Output $logEntry
        }
        catch {
            # If logging fails, at least output to console
            Write-Output "LOGGING ERROR: $($_.Exception.Message) - Original message: $Message"
        }
    }
    else {
        # If logging is disabled, just output to console
        Write-Output "[$Level] $Message"
    }
}

# Function to create Azure Storage authentication header for Table API
function New-TableAuthHeader {
    param($StorageAccountName, $StorageAccountKey, $Method, $Resource, $Date, $ContentLength = "")
    
    $stringToSign = ""
    $stringToSign += $Method
    $stringToSign += "`n"
    $stringToSign += ""
    $stringToSign += "`n"
    $stringToSign += "application/json"
    $stringToSign += "`n"
    $stringToSign += $Date
    $stringToSign += "`n"
    $stringToSign += "/$StorageAccountName$Resource"
    
    Write-Verbose "String to sign: '$stringToSign'"
    
    $key = [Convert]::FromBase64String($StorageAccountKey)
    $hmac = New-Object System.Security.Cryptography.HMACSHA256
    $hmac.Key = $key
    $signature = [Convert]::ToBase64String($hmac.ComputeHash([Text.Encoding]::UTF8.GetBytes($stringToSign)))
    
    Write-Verbose "Signature: $signature"
    
    return "SharedKey $StorageAccountName`:$signature"
}

# Start logging
Write-Log "========================================" "INFO"
Write-Log "Windows Health Check Script Started" "INFO"
Write-Log "Log file: $LogFile" "INFO"
Write-Log "Script version: 0.9.0" "INFO"
Write-Log "========================================" "INFO"

Write-Log "Running Windows Image Health Check..." "INFO"

if ($UploadToStorageAccount) {
    Write-Log "Upload Policy: Upload results to Azure Storage Account" "INFO"
}
else {
    Write-Log "Upload Policy: Local processing only - no upload" "INFO"
}

# Run health check
Write-Log "Running Windows Image Health Scan..." "INFO"
try {
    $imageHealthResult = Repair-WindowsImage -Online -ScanHealth -ErrorAction Stop
    
    if (!$imageHealthResult) {
        Write-Log "Warning: Image health scan returned null result" "WARNING"
        $imageHealthResult = @{
            ImageHealthState = "ScanFailed"
            RestartNeeded = $false
        }
    }
    elseif ($null -eq $imageHealthResult.ImageHealthState.ToString() -or $imageHealthResult.ImageHealthState.ToString() -eq "") {
        Write-Log "Warning: Image health state is null or empty" "WARNING"
        $imageHealthResult.ImageHealthState = "Unknown"
    }
    
    Write-Log "Health check completed: $($imageHealthResult.ImageHealthState.ToString())" "INFO"
}
catch {
    Write-Log "Error: Image health scan failed: $($_.Exception.Message)" "ERROR"
    $imageHealthResult = @{
        ImageHealthState = "ScanFailed"
        RestartNeeded = $false
    }
    Write-Log "Using fallback health state: ScanFailed" "WARNING"
}

# Initialize variables for tracking actions
$imageRepaired = $false
$updatesInstalled = @()
$updatesFound = @()
$updatesFailed = @()
$rebootRequired = $false

# If image health is Repairable, run RestoreHealth
if ($imageHealthResult.ImageHealthState -eq "Repairable") {
    Write-Log "Image is repairable. Running Repair-WindowsImage -Online -RestoreHealth..." "INFO"
    try {
        Repair-WindowsImage -Online -RestoreHealth | Out-Null
        Write-Log "Image repair completed successfully" "INFO"
        $imageRepaired = $true
    }
    catch {
        Write-Log "Image repair failed: $($_.Exception.Message)" "ERROR"
        $imageRepaired = $false
    }
}

# Run Windows Update using native COM objects
Write-Log "Checking for Windows Updates..." "INFO"
try {
    # Create Windows Update session
    $UpdateSession = New-Object -ComObject Microsoft.Update.Session
    $UpdateSearcher = $UpdateSession.CreateUpdateSearcher()
    
    Write-Output "Searching for available updates..."
    # Search for all non-hidden, non-installed updates (includes cumulative updates, security updates, etc.)
    # This broader search will catch cumulative updates that might be categorized differently
    $SearchResult = $UpdateSearcher.Search("IsInstalled=0 and IsHidden=0")
    
    Write-Output "Found $($SearchResult.Updates.Count) total updates to evaluate"
    
    if ($SearchResult.Updates.Count -gt 0) {
        Write-Output "Found $($SearchResult.Updates.Count) available updates"
        
        # Debug: List all found updates before filtering
        Write-Output "DEBUG: All updates found in search:"
        foreach ($Update in $SearchResult.Updates) {
            Write-Output "  DEBUG: $($Update.Title)"
        }
        Write-Output "" # Empty line for readability
        
        # Create update collection for download/install
        $UpdatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl
        
        foreach ($Update in $SearchResult.Updates) {
            # Track all updates found for reporting
            $kbNumber = ""
            if ($Update.Title -match "KB\d+") {
                $kbNumber = $matches[0]
            }
            
            $updatesFound += @{
                Title = $Update.Title
                KB = $kbNumber
                Size = [math]::Round($Update.MaxDownloadSize / 1MB, 2)
                IsDriver = $false  # Will be updated below if it's a driver
            }
            
            # Filter out driver updates but keep everything else (including cumulative updates)
            $isDriverUpdate = $false
                  
            foreach ($category in $Update.Categories) {
                if ($category.Name -like "*Driver*" -or $category.CategoryID -eq "ebfc1fc5-71a4-4f7b-9aca-3b9a503104a0") {
                    $isDriverUpdate = $true
                    # Mark this update as a driver in our tracking array
                    $updatesFound[-1].IsDriver = $true
                    break
                }
            }
            
            # Special handling for .NET Framework and Security platform updates
            $updateTitle = $Update.Title  
            
            if ($updateTitle -like "*.NET Framework*" -or 
                $updateTitle -like "*Windows Security platform*" -or
                $updateTitle -like "*Cumulative Update*" -or
                $updateTitle -match "KB\d{7}" -or
                $updateTitle -like "*Security Update*" -or
                $updateTitle -like "*Critical Update*" -or
                $updateTitle -like "*Quality Update*" -or
                $updateTitle -like "*Monthly Rollup*") {
                $isSpecialUpdate = $true
            }
            
            # Don't skip drivers, but be more inclusive for important updates
            if (-not $isDriverUpdate) {
                if ($Update.EulaAccepted -eq $false) {
                    $Update.AcceptEula()
                }
                $UpdatesToInstall.Add($Update) | Out-Null
                
                # Show update type for debugging
                $updateType = "Other"
                
                # Enhanced detection for different update types
                if ($updateTitle -match "Cumulative|KB\d{7}" -or $updateTitle -like "*Monthly Rollup*" -or $updateTitle -like "*Quality Update*") {
                    $updateType = "Cumulative"
                }
                elseif ($updateTitle -like "*.NET Framework*") {
                    $updateType = ".NET Framework"
                }
                elseif ($updateTitle -like "*Windows Security platform*" -or $updateTitle -like "*Security Update*" -or $updateTitle -like "*Defender*") {
                    $updateType = "Security"  
                }
                elseif ($updateTitle -like "*Critical*" -or $updateTitle -like "*Important*") {
                    $updateType = "Critical"
                }
                elseif ($updateTitle -like "*Optional*" -or $updateTitle -like "*Preview*") {
                    $updateType = "Optional"
                }
                
                # Also check categories for better classification
                foreach ($category in $Update.Categories) {
                    $categoryName = $category.Name
                    if ($categoryName -like "*Updates*" -and ($updateTitle -like "*Cumulative*" -or $updateTitle -match "KB\d{7}")) {
                        $updateType = "Cumulative"
                        break
                    }
                    elseif ($categoryName -like "*Security*") {
                        $updateType = "Security"
                        break
                    }
                    elseif ($categoryName -like "*.NET*" -or $categoryName -like "*Framework*") {
                        $updateType = ".NET Framework"
                        break
                    }
                }
                
                Write-Output "  - [$updateType] $($Update.Title)"
            }
            else {
                Write-Output "  - [SKIPPED - Driver] $($Update.Title)"
            }
        }
        
        Write-Output "Updates added to collection: $($UpdatesToInstall.Count)"
        
        if ($UpdatesToInstall.Count -gt 0) {
            Write-Output "Downloading updates..."
            
            # Download updates
            $Downloader = $UpdateSession.CreateUpdateDownloader()
            $Downloader.Updates = $UpdatesToInstall
            $DownloadResult = $Downloader.Download()
            
            Write-Output "Download result code: $($DownloadResult.ResultCode)"
            
            if ($DownloadResult.ResultCode -eq 2) {
                # OperationResultCodeSucceeded
                Write-Output "Download completed successfully. Installing updates..."
                
                # Install updates
                $Installer = $UpdateSession.CreateUpdateInstaller()
                $Installer.Updates = $UpdatesToInstall
                Write-Output "Starting installation of $($UpdatesToInstall.Count) updates..."
                $InstallationResult = $Installer.Install()
                
                Write-Output "Installation result code: $($InstallationResult.ResultCode)"
                
                # Track installed updates
                for ($i = 0; $i -lt $UpdatesToInstall.Count; $i++) {
                    $update = $UpdatesToInstall.Item($i)
                    $updateResult = $InstallationResult.GetUpdateResult($i)
                    
                    Write-Output "Update $($i+1): $($update.Title) - Result: $($updateResult.ResultCode)"
                    
                    # Extract KB number from title if available
                    $kbNumber = ""
                    if ($update.Title -match "KB\d+") {
                        $kbNumber = $matches[0]
                    }
                    
                    $updatesInstalled += @{
                        Title          = $update.Title
                        KB             = $kbNumber
                        Size           = [math]::Round($update.MaxDownloadSize / 1MB, 2)
                        ResultCode     = $updateResult.ResultCode
                        Status         = switch ($updateResult.ResultCode) {
                            0 { "NotStarted" }
                            1 { "InProgress" }
                            2 { "Succeeded" }
                            3 { "SucceededWithErrors" }
                            4 { "Failed" }
                            5 { "Aborted" }
                            default { "Unknown" }
                        }
                        RebootRequired = $updateResult.RebootRequired
                    }
                }
                
                # Check if any update requires reboot
                $rebootRequired = $InstallationResult.RebootRequired -or ($updatesInstalled | Where-Object { $_.RebootRequired } | Measure-Object).Count -gt 0
                
                Write-Output "Installed $($updatesInstalled.Count) updates"
                Write-Output "Installation result code: $($InstallationResult.ResultCode)"
                Write-Output "Reboot required: $rebootRequired"
            }
            else {
                Write-Output "Download failed with result code: $($DownloadResult.ResultCode)"
                
                # Track all updates that failed to download
                for ($i = 0; $i -lt $UpdatesToInstall.Count; $i++) {
                    $update = $UpdatesToInstall.Item($i)
                    
                    # Extract KB number from title if available
                    $kbNumber = ""
                    if ($update.Title -match "KB\d+") {
                        $kbNumber = $matches[0]
                    }
                    
                    $updatesFailed += @{
                        Title = $update.Title
                        KB = $kbNumber
                        Size = [math]::Round($update.MaxDownloadSize / 1MB, 2)
                        FailureReason = "Download failed with result code: $($DownloadResult.ResultCode)"
                        FailureStage = "Download"
                    }
                }
            }
        }
        else {
            Write-Output "Warning: No updates were added to the installation collection"
            Write-Output "This might indicate an issue with update collection or permissions"
            
            # Try alternative approach - install updates individually
            Write-Output "Attempting to install updates individually..."
            
            foreach ($Update in $SearchResult.Updates) {
                try {
                    Write-Output "Processing: $($Update.Title)"
                    
                    if ($Update.EulaAccepted -eq $false) {
                        $Update.AcceptEula()
                    }
                    
                    # Create individual collection
                    $IndividualCollection = New-Object -ComObject Microsoft.Update.UpdateColl
                    $IndividualCollection.Add($Update) | Out-Null
                    
                    # Download individual update
                    $IndividualDownloader = $UpdateSession.CreateUpdateDownloader()
                    $IndividualDownloader.Updates = $IndividualCollection
                    $IndividualDownloadResult = $IndividualDownloader.Download()
                    
                    if ($IndividualDownloadResult.ResultCode -eq 2) {
                        # Install individual update
                        $IndividualInstaller = $UpdateSession.CreateUpdateInstaller()
                        $IndividualInstaller.Updates = $IndividualCollection
                        $IndividualInstallResult = $IndividualInstaller.Install()
                        
                        # Extract KB number from title if available
                        $kbNumber = ""
                        if ($Update.Title -match "KB\d+") {
                            $kbNumber = $matches[0]
                        }
                        
                        $updatesInstalled += @{
                            Title          = $Update.Title
                            KB             = $kbNumber
                            Size           = [math]::Round($Update.MaxDownloadSize / 1MB, 2)
                            ResultCode     = $IndividualInstallResult.ResultCode
                            Status         = switch ($IndividualInstallResult.ResultCode) {
                                0 { "NotStarted" }
                                1 { "InProgress" }
                                2 { "Succeeded" }
                                3 { "SucceededWithErrors" }
                                4 { "Failed" }
                                5 { "Aborted" }
                                default { "Unknown" }
                            }
                            RebootRequired = $IndividualInstallResult.RebootRequired
                        }
                        
                        Write-Output "  Installed: $($Update.Title) - Result: $($IndividualInstallResult.ResultCode)"
                        
                        if ($IndividualInstallResult.RebootRequired) {
                            $rebootRequired = $true
                        }
                    }
                    else {
                        Write-Output "  Download failed for: $($Update.Title)"
                        
                        # Track individual download failure
                        $kbNumber = ""
                        if ($Update.Title -match "KB\d+") {
                            $kbNumber = $matches[0]
                        }
                        
                        $updatesFailed += @{
                            Title = $Update.Title
                            KB = $kbNumber
                            Size = [math]::Round($Update.MaxDownloadSize / 1MB, 2)
                            FailureReason = "Individual download failed with result code: $($IndividualDownloadResult.ResultCode)"
                            FailureStage = "Individual Download"
                        }
                    }
                }
                catch {
                    Write-Log "  Error processing update $($Update.Title): $($_.Exception.Message)" "ERROR"
                    
                    # Track individual processing failure
                    $kbNumber = ""
                    if ($Update.Title -match "KB\d+") {
                        $kbNumber = $matches[0]
                    }
                    
                    $updatesFailed += @{
                        Title = $Update.Title
                        KB = $kbNumber
                        Size = if ($Update.MaxDownloadSize) { [math]::Round($Update.MaxDownloadSize / 1MB, 2) } else { 0 }
                        FailureReason = "Processing error: $($_.Exception.Message)"
                        FailureStage = "Individual Processing"
                    }
                }
            }
            
            Write-Output "Individual installation completed. Total updates processed: $($updatesInstalled.Count)"
        }
    }
    else {
        Write-Output "No updates available"
    }
}
catch {
    Write-Log "Windows Update check/install failed: $($_.Exception.Message)" "ERROR"
    
    # Track general Windows Update failure
    $updatesFailed += @{
        Title = "Windows Update Process"
        KB = "N/A"
        Size = 0
        FailureReason = "Windows Update check/install failed: $($_.Exception.Message)"
        FailureStage = "Windows Update Process"
    }
}

# Determine if we should upload based on configuration
$shouldUpload = $UploadToStorageAccount
$uploadReason = if ($UploadToStorageAccount) { 
    "Upload to storage account enabled" 
} else { 
    "Upload to storage account disabled" 
}

if ($shouldUpload) {
    Write-Output "Upload Decision: $uploadReason"
}
else {
    Write-Output "Upload Decision: $uploadReason"
}

if ($shouldUpload) {
    # Insert entity into existing table
    try {
        # Use alternative method for date in constrained environments
        $currentDate = Get-Date -ErrorAction SilentlyContinue
        if ($null -eq $currentDate) {
            $currentDate = [System.DateTime]::Now
        }
        
        $date = $currentDate.ToUniversalTime().ToString("R")
        
        # Generate a safer RowKey
        $computerName = if ($env:COMPUTERNAME) { $env:COMPUTERNAME } else { "Unknown" }
        $timestamp = $currentDate.ToString('yyyyMMdd-HHmmss')
        $rowKey = "$computerName-$timestamp"
        
        # Convert updates to JSON string for storage with error handling
        $updatesJson = "[]"
        if ($updatesInstalled.Count -gt 0) {
            try {
                $updatesJson = ($updatesInstalled | ConvertTo-Json -Compress -ErrorAction Stop)
            }
            catch {
                Write-Log "Warning: Failed to convert updates to JSON, using empty array" "WARNING"
                $updatesJson = "[]"
            }
        }
        
        # Convert updates found to JSON string for storage
        $updatesFoundJson = "[]"
        if ($updatesFound.Count -gt 0) {
            try {
                $updatesFoundJson = ($updatesFound | ConvertTo-Json -Compress -ErrorAction Stop)
            }
            catch {
                Write-Log "Warning: Failed to convert updates found to JSON, using empty array" "WARNING"
                $updatesFoundJson = "[]"
            }
        }
        
        # Convert update failures to JSON string for storage
        $updatesFailedJson = "[]"
        if ($updatesFailed.Count -gt 0) {
            try {
                $updatesFailedJson = ($updatesFailed | ConvertTo-Json -Compress -ErrorAction Stop)
            }
            catch {
                Write-Log "Warning: Failed to convert update failures to JSON, using empty array" "WARNING"
                $updatesFailedJson = "[]"
            }
        }
        
        # Create entity hashtable
        $entityData = @{
            PartitionKey     = "WindowsHealth"
            RowKey           = $rowKey
            ComputerName     = $computerName
            ImageHealthState = $imageHealthResult.ImageHealthState.ToString()
            RestartNeeded    = $imageHealthResult.RestartNeeded.ToString()
            CheckDateTime    = $currentDate.ToString('yyyy-MM-dd HH:mm:ss')
            UploadReason     = if ($uploadReason) { $uploadReason } else { "Unknown" }
            ImageRepaired    = $imageRepaired.ToString()
            UpdatesInstalled = $updatesJson
            UpdatesCount     = $updatesInstalled.Count
            UpdatesFound     = $updatesFoundJson
            UpdatesFoundCount = $updatesFound.Count
            UpdatesFailed    = $updatesFailedJson
            UpdatesFailedCount = $updatesFailed.Count
            RebootRequired   = $rebootRequired.ToString()
        }
        
        # Convert to JSON with error handling
        $entity = $null
        try {
            $entity = $entityData | ConvertTo-Json -ErrorAction Stop
        }
        catch {
            Write-Log "Error: Failed to convert entity to JSON: $($_.Exception.Message)" "ERROR"
            Write-Log "Attempting manual JSON creation..." "WARNING"
            
            # Manual JSON creation as fallback
            $entity = @"
{
    "PartitionKey": "$($entityData.PartitionKey)",
    "RowKey": "$($entityData.RowKey)",
    "ComputerName": "$($entityData.ComputerName)",
    "ImageHealthState": "$($entityData.ImageHealthState)",
    "RestartNeeded": "$($entityData.RestartNeeded)",
    "CheckDateTime": "$($entityData.CheckDateTime)",
    "UploadReason": "$($entityData.UploadReason)",
    "ImageRepaired": "$($entityData.ImageRepaired)",
    "UpdatesInstalled": $($entityData.UpdatesInstalled),
    "UpdatesCount": $($entityData.UpdatesCount),
    "UpdatesFound": $($entityData.UpdatesFound),
    "UpdatesFoundCount": $($entityData.UpdatesFoundCount),
    "UpdatesFailed": $($entityData.UpdatesFailed),
    "UpdatesFailedCount": $($entityData.UpdatesFailedCount),
    "RebootRequired": "$($entityData.RebootRequired)"
}
"@
        }
        
        # Validate entity is not null
        if ($null -eq $entity -or $entity.Length -eq 0) {
            throw "Entity JSON is null or empty"
        }
        
        # Calculate content length safely
        $contentLength = 0
        try {
            $contentLength = [System.Text.Encoding]::UTF8.GetByteCount($entity)
        }
        catch {
            Write-Log "Warning: Failed to calculate content length, using string length" "WARNING"
            $contentLength = $entity.Length
        }

        $headers = @{
            "x-ms-date"     = $date
            "x-ms-version"  = "2019-02-02"
            "Accept"        = "application/json;odata=nometadata"
            "Content-Type"  = "application/json"
            "Authorization" = New-TableAuthHeader $StorageAccountName $StorageAccountKey "POST" "/$TableName" $date
        }

        Write-Output "Uploading to table: $TableName"
        Write-Output "Date: $date"

        $VerbosePreference = "Continue"

        try {
            $response = Invoke-RestMethod -Uri "https://$StorageAccountName.table.core.windows.net/$TableName" -Method POST -Headers $headers -Body $entity -ContentType "application/json" -Verbose
            Write-Log "UPLOAD SUCCESS: Health: $($entityData.ImageHealthState), Restart: $($entityData.RestartNeeded), Updates Found: $($updatesFound.Count), Updates Installed: $($updatesInstalled.Count), Updates Failed: $($updatesFailed.Count), Image Repaired: $imageRepaired, Reboot Required: $rebootRequired" "INFO"
        }
        catch {
            Write-Log "UPLOAD FAILED" "ERROR"
            Write-Log "Error Details:" "ERROR"
            
            if ($_.Exception.Response) {
                Write-Log "Status Code: $($_.Exception.Response.StatusCode)" "ERROR"
                Write-Log "Status Description: $($_.Exception.Response.StatusDescription)" "ERROR"
            }
            
            Write-Log "Full Error: $($_.Exception.Message)" "ERROR"
            
            if ($_.Exception.Response) {
                try {
                    $streamReader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                    $responseBody = $streamReader.ReadToEnd()
                    Write-Log "Response Body: $responseBody" "ERROR"
                    $streamReader.Close()
                }
                catch {
                    Write-Log "Could not read response body" "WARNING"
                }
            }
        }
    }
    catch {
        Write-Log "UPLOAD PREPARATION FAILED: $($_.Exception.Message)" "ERROR"
        Write-Log "Continuing with script execution..." "WARNING"
    }
}
else {
    $healthStateDisplay = if ($imageHealthResult -and $imageHealthResult.ImageHealthState) { 
        $imageHealthResult.ImageHealthState 
    } else { 
        "ScanFailed" 
    }
    $restartNeededDisplay = if ($imageHealthResult -and $imageHealthResult.RestartNeeded) { 
        $imageHealthResult.RestartNeeded 
    } else { 
        "False" 
    }
    
    Write-Output "SKIPPED UPLOAD: Health: $healthStateDisplay, Restart: $restartNeededDisplay, Updates Found: $($updatesFound.Count), Updates Installed: $($updatesInstalled.Count), Updates Failed: $($updatesFailed.Count), Image Repaired: $imageRepaired, Reboot Required: $rebootRequired"
    Write-Output "Reason: $uploadReason"
}

Write-Output ""
Write-Output "Summary:"
Write-Output "  Computer: $(if ($env:COMPUTERNAME) { $env:COMPUTERNAME } else { 'Unknown' })"
Write-Output "  Health State: $(if ($imageHealthResult -and $imageHealthResult.ImageHealthState) { $imageHealthResult.ImageHealthState } else { 'ScanFailed' })"
Write-Output "  Restart Needed: $(if ($imageHealthResult -and $imageHealthResult.RestartNeeded) { $imageHealthResult.RestartNeeded } else { 'False' })"
Write-Output "  Image Repaired: $imageRepaired"
Write-Output "  Updates Found: $($updatesFound.Count)"
Write-Output "  Updates Installed: $($updatesInstalled.Count)"
Write-Output "  Updates Failed: $($updatesFailed.Count)"
Write-Output "  Reboot Required: $rebootRequired"

if ($UploadToStorageAccount) {
    Write-Output "  Upload Policy: Enabled"
} else {
    Write-Output "  Upload Policy: Disabled"
}

if ($shouldUpload) {
    Write-Output "  Action Taken: Uploaded to Azure"
}
else {
    Write-Output "  Action Taken: Local check only"
}

# Handle reboot if required
if ($rebootRequired) {
    Write-Log "Reboot required. Initiating system restart..." "WARNING"
    Write-Log "========================================" "INFO"
    Write-Log "Script execution completed - REBOOT PENDING" "INFO"
    Write-Log "========================================" "INFO"
    
    Restart-Computer -Force
}
else {
    Write-Log "========================================" "INFO"
    Write-Log "Script execution completed successfully" "INFO"
    Write-Log "========================================" "INFO"
}