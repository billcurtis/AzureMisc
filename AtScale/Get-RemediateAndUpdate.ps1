<#

Version  0.9.5

.DESCRIPTION
    This script performs a comprehensive Windows Image Health Check with automatic repair capabilities,
    checks for and installs Windows Updates (excluding driver updates), and uploads the results
    to an Azure Storage Table for tracking and analysis. The script is designed to work safely in both
    interactive and constrained environments such as Invoke-AzVMRunCommand.

    Key Features:
    - Intelligent execution history checking via Azure Storage Table to prevent unnecessary runs
      * Queries storage table for latest execution results by computer name
      * Only runs if: no previous record exists, system is unhealthy, or repairs are needed
      * Configurable bypass option for execution history checking
    - Intelligent user session detection with configurable bypass and wait options
      * Can skip operations when users are logged in (default behavior)
      * Optional wait-and-retry feature: waits for users to log off before proceeding
      * Configurable wait interval with automatic recheck of user sessions
    - Advanced Windows Image health management with automatic repair workflow:
      * Performs initial health scan using Repair-WindowsImage -ScanHealth
      * Automatically runs RestoreHealth when image status is "Repairable"
      * Captures detailed repair operation results and restart requirements
      * Performs post-repair verification health check to confirm repair success
      * Comprehensive status tracking for all repair scenarios (success, failure, not needed)
    - Utilizes native COM objects to interact with Windows Update for better compatibility in constrained environments
    - Filters out driver updates while ensuring important updates (cumulative, security, .NET) are included
    - Detects constrained execution environments and adapts behavior accordingly
    - Provides detailed logging with timestamp and hostname for better tracking of all operations
    - Handles errors gracefully with comprehensive error recovery mechanisms
    - Uploads results to Azure Storage Table with robust error handling and retry logic
    - Safe execution model that skips operations when users are actively logged in (configurable)
    - Complete audit trail of image health status before, during, and after repair operations

.REQUIRES
    - PowerShell 5.1 or later
    - Azure Storage Account with Table service enabled
    - Appropriate permissions to run Windows Update and Repair-WindowsImage

.NOTES

Portions generated by AI (Claude Sonnet 4).

#>

# Enforce TLS 1.2 for secure HTTPS connections to Azure Storage
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Load required assemblies for URL encoding
Add-Type -AssemblyName System.Web

# Hardcoded configuration
$UploadToStorageAccount = $true
$StorageAccountName = "<YOUR_STORAGE_ACCOUNT_NAME>"
$StorageAccountKey = "<YOUR_STORAGE_ACCOUNT_KEY>"
$TableName = "WindowsImageHealth"
$SkipUserSessionCheck = $false # Set to $true to bypass user session checking
$SkipStorageTableCheck = $false  # Set to $true to bypass storage table history checking

# User session wait and retry configuration
# If WaitForUsersToLogOff is $true, the script will wait for users to log off instead of skipping immediately
# When users are detected, it will wait for WaitRetryIntervalMinutes and then recheck
# This process will repeat for MaxRetryAttempts before finally skipping operations
$WaitForUsersToLogOff = $true  # Set to $true to wait for users to log off instead of skipping
$WaitRetryIntervalMinutes = 120  # Number of minutes to wait before rechecking for logged-on users
$MaxRetryAttempts = 3  # Maximum number of retry attempts (total wait time = MaxRetryAttempts * WaitRetryIntervalMinutes)

# Initialize error handling for constrained environments
$ErrorActionPreference = "Continue"

# Initialize variables at script level to ensure they're available throughout
$imageHealthResult = @{
    ImageHealthState = "Not Started"
    RestartNeeded = $false
}
$imageRepaired = $false
$afterRepairStatus = "N/A"
$updatesInstalled = @()
$updatesFound = @()
$updatesFailed = @()
$rebootRequired = $false

# Detect if running in a constrained environment (like Invoke-AzVMRunCommand)
$isConstrainedEnvironment = $false
try {
    # Check for indicators of constrained environment
    if ($env:AzureClientId -or $env:MSI_ENDPOINT -or $env:AZURE_CLIENT_ID -or 
        (Test-Path env:COMPUTERNAME) -and $env:COMPUTERNAME -like "*-*" -and
        $PSVersionTable.PSVersion.Major -eq 5) {
        $isConstrainedEnvironment = $true
    }
    
    # Additional check for Invoke-AzVMRunCommand context
    if ($env:PROCESSOR_ARCHITECTURE -and $env:TEMP -and 
        (Get-Process -Name "cmd" -ErrorAction SilentlyContinue) -and
        $Host.Name -eq "ConsoleHost") {
        $isConstrainedEnvironment = $true
    }
}
catch {
    # If we can't determine, assume constrained for safety
    $isConstrainedEnvironment = $true
}

if ($isConstrainedEnvironment) {
    Write-Output "Detected constrained environment (likely Invoke-AzVMRunCommand) - adapting script behavior"
}

# Initialize logging
$LogPath = "C:\temp"
$LogFile = Join-Path $LogPath "WindowsHealthCheck-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"

# Create log directory if it doesn't exist
if (-not (Test-Path $LogPath)) {
    try {
        New-Item -Path $LogPath -ItemType Directory -Force | Out-Null
        Write-Output "Created log directory: $LogPath"
    }
    catch {
        Write-Output "Warning: Failed to create log directory: $($_.Exception.Message)"
        $LogFile = $null  # Disable logging if we can't create the directory
    }
}

# Logging function
function Write-Log {
    param(
        [string]$Message,
        [ValidateSet("INFO", "WARNING", "ERROR", "DEBUG")]
        [string]$Level = "INFO"
    )
    
    if ($null -ne $LogFile) {
        try {
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $computerName = if ($env:COMPUTERNAME) { $env:COMPUTERNAME } else { "Unknown" }
            $logEntry = "[$timestamp] [$computerName] [$Level] $Message"
            
            # Write to log file
            Add-Content -Path $LogFile -Value $logEntry -ErrorAction SilentlyContinue
            
            # Also write to console for immediate visibility
            Write-Output $logEntry
        }
        catch {
            # If logging fails, at least output to console
            Write-Output "LOGGING ERROR: $($_.Exception.Message) - Original message: $Message"
        }
    }
    else {
        # If logging is disabled, just output to console
        Write-Output "[$Level] $Message"
    }
}

# Function to check for active logged-on users (excluding system accounts)
function Get-LoggedOnUsers {
    $userNames = @()
    
    try {
        # Get active user sessions using quser command
        try {
            $quserOutput = quser 2>$null
            if ($LASTEXITCODE -eq 0 -and $quserOutput) {
                # Skip header line and process each user line
                for ($i = 1; $i -lt $quserOutput.Count; $i++) {
                    $line = $quserOutput[$i].Trim()
                    if (-not $line -or $line.Length -lt 10) { continue }
                    
                    # Remove '>' prefix if present (current session indicator)
                    if ($line.StartsWith('>')) {
                        $line = $line.Substring(1).Trim()
                    }
                    
                    # Split the line and extract username and state
                    $parts = $line -split '\s+', 6
                    if ($parts.Count -lt 3) { continue }
                    
                    $username = $parts[0].Trim()
                    
                    # Determine the state based on line format
                    $state = $null
                    if ($parts[1] -match '^\d+$') {
                        # Format: USERNAME ID STATE ...
                        $state = if ($parts.Count -gt 2) { $parts[2] } else { $null }
                    } else {
                        # Format: USERNAME SESSIONNAME ID STATE ...
                        $state = if ($parts.Count -gt 3) { $parts[3] } else { $null }
                    }
                    
                    # Only include real users (not system accounts) in Active or Disc state
                    if ($username -and 
                        $username.Length -gt 1 -and
                        $username -notmatch '^(SYSTEM|LOCAL SERVICE|NETWORK SERVICE|DWM-\d+|UMFD-\d+)$' -and 
                        $username -notlike "*console*" -and
                        $username -notlike "*services*" -and
                        $state -and ($state -eq 'Active' -or $state -eq 'Disc')) {
                        
                        $userNames += $username
                    }
                }
            }
        }
        catch {
            # Silently continue to WMI fallback
        }
        
        # If quser failed or found no users, try WMI as fallback
        if ($userNames.Count -eq 0) {
            try {
                $sessions = Get-WmiObject -Class Win32_LogonSession -ErrorAction Stop | Where-Object { $_.LogonType -eq 2 -or $_.LogonType -eq 10 }
                
                foreach ($session in $sessions) {
                    try {
                        $user = Get-WmiObject -Class Win32_LoggedOnUser -ErrorAction SilentlyContinue | 
                                Where-Object { $_.Dependent.LogonId -eq $session.LogonId } |
                                Select-Object -First 1
                        
                        if ($user) {
                            $username = $user.Antecedent.Name -replace '.*Name="([^"]+)".*', '$1'
                            $domain = $user.Antecedent.Domain -replace '.*Domain="([^"]+)".*', '$1'
                            $fullUsername = if ($domain -and $domain -ne $username) { "$domain\$username" } else { $username }
                            
                            # Filter out system accounts
                            if ($username -and 
                                $username -notmatch '^(SYSTEM|LOCAL SERVICE|NETWORK SERVICE|DWM-\d+|UMFD-\d+|\$|Anonymous)' -and 
                                $username -ne $env:COMPUTERNAME) {
                                
                                $userNames += $fullUsername
                            }
                        }
                    }
                    catch {
                        # Continue to next session
                    }
                }
            }
            catch {
                # WMI also failed, return empty array
            }
        }
        
        # Remove duplicates and return unique usernames
        $uniqueUsers = $userNames | Sort-Object -Unique
        return $uniqueUsers
    }
    catch {
        return @()
    }
}

# Function to create Azure Storage authentication header for Table API
function New-TableAuthHeader {
    param($StorageAccountName, $StorageAccountKey, $Method, $Resource, $Date, $ContentLength = "")
    
    $stringToSign = ""
    $stringToSign += $Method
    $stringToSign += "`n"
    $stringToSign += ""
    $stringToSign += "`n"
    $stringToSign += "application/json"
    $stringToSign += "`n"
    $stringToSign += $Date
    $stringToSign += "`n"
    $stringToSign += "/$StorageAccountName$Resource"
    
    Write-Verbose "String to sign: '$stringToSign'"
    
    $key = [Convert]::FromBase64String($StorageAccountKey)
    $hmac = New-Object System.Security.Cryptography.HMACSHA256
    $hmac.Key = $key
    $signature = [Convert]::ToBase64String($hmac.ComputeHash([Text.Encoding]::UTF8.GetBytes($stringToSign)))
    
    Write-Verbose "Signature: $signature"
    
    return "SharedKey $StorageAccountName`:$signature"
}

# Function to get the latest record for a computer from the storage table
function Get-LatestTableRecord {
    param(
        [string]$StorageAccountName,
        [string]$StorageAccountKey,
        [string]$TableName,
        [string]$ComputerName
    )
    
    try {
        Write-Log "Checking storage table for latest record for computer: $ComputerName" "INFO" | Out-Null
        $latestRecord = $null
        # Use alternative method for date in constrained environments
        $currentDate = Get-Date -ErrorAction SilentlyContinue
        if ($null -eq $currentDate) {
            $currentDate = [System.DateTime]::Now
        }
        
        $date = $currentDate.ToUniversalTime().ToString("R")
        
        # First, try to get all records for the computer (simpler query)
        # We'll filter and sort in PowerShell instead of using complex OData queries
        $filter = "ComputerName eq '$ComputerName'"
        $queryString = "?`$filter=$filter"
        $resource = "/$TableName()"
        
        $headers = @{
            "x-ms-date"     = $date
            "x-ms-version"  = "2019-02-02"
            "Accept"        = "application/json;odata=nometadata"
            "Authorization" = New-TableAuthHeader $StorageAccountName $StorageAccountKey "GET" $resource $date
        }
        
        $uri = "https://$StorageAccountName.table.core.windows.net$resource$queryString"
        Write-Log "Querying storage table: $uri" "DEBUG" | Out-Null
        
        $response = Invoke-RestMethod -Uri $uri -Method GET -Headers $headers -ContentType "application/json"
        
        if ($response.value -and $response.value.Count -gt 0) {
            
            # Sort by CheckDateTime descending and get the latest record
            $latestRecord = $response.value | Sort-Object CheckDateTime -Descending | Select-Object -First 1
            
            # Additional validation: ensure the record actually has meaningful data
            if ($latestRecord -and 
                $latestRecord.ComputerName -and 
                $latestRecord.ComputerName -eq $ComputerName -and
                $latestRecord.ImageHealthState) {
                Write-Log "Found latest record for $ComputerName - ImageHealthState: $($latestRecord.ImageHealthState), AfterRepairStatus: $($latestRecord.AfterRepairStatus), ImageRepaired: $($latestRecord.ImageRepaired)" "INFO" | Out-Null
                return $latestRecord
            }
            else {
                Write-Log "Record found but has invalid/empty data - treating as no record" "INFO" | Out-Null
                return $null
            }
            else {
                Write-Log "No records found after sorting for computer: $ComputerName" "INFO" | Out-Null 
                return $null
            }
        }
        else {
            Write-Log "No records found for computer: $ComputerName" "INFO" | Out-Null
            return $null
        }
    }
    catch {
        Write-Log "Error querying storage table: $($_.Exception.Message)" "ERROR" | Out-Null
        
        # Try a simpler approach - get all records and filter locally
        try {
            Write-Log "Attempting simplified query approach..." "INFO"
            
            $date = $currentDate.ToUniversalTime().ToString("R")
            $resource = "/$TableName()"
            
            $headers = @{
                "x-ms-date"     = $date
                "x-ms-version"  = "2019-02-02"
                "Accept"        = "application/json;odata=nometadata"
                "Authorization" = New-TableAuthHeader $StorageAccountName $StorageAccountKey "GET" $resource $date
            }
            
            $uri = "https://$StorageAccountName.table.core.windows.net$resource"
            Write-Log "Attempting simple query: $uri" "DEBUG" | Out-Null
            
            $response = Invoke-RestMethod -Uri $uri -Method GET -Headers $headers -ContentType "application/json"
            
            if ($response.value -and $response.value.Count -gt 0) {
                # Filter by computer name and sort by CheckDateTime descending
                $computerRecords = $response.value | Where-Object { $_.ComputerName -eq $ComputerName }
                
                if ($computerRecords -and $computerRecords.Count -gt 0) {
                    $latestRecord = $computerRecords | Sort-Object CheckDateTime -Descending | Select-Object -First 1
                    
                    # Additional validation for fallback query as well
                    if ($latestRecord -and 
                        $latestRecord.ComputerName -and 
                        $latestRecord.ComputerName -eq $ComputerName -and
                        $latestRecord.ImageHealthState) {
                        Write-Log "Found latest record for $ComputerName using fallback method - ImageHealthState: $($latestRecord.ImageHealthState)" "INFO" | Out-Null
                        return $latestRecord
                    }
                    else {
                        Write-Log "Fallback record found but has invalid/empty data - treating as no record" "INFO" | Out-Null
                        return $null
                    }
                }
                else {
                    Write-Log "No records found for computer $ComputerName using fallback method" "INFO" | Out-Null
                    return $null
                }
            }
            else {
                Write-Log "No records found in table using fallback method" "INFO" | Out-Null
                return $null
            }
        }
        catch {
            Write-Log "Fallback query also failed: $($_.Exception.Message)" "ERROR" | Out-Null
            Write-Log "Assuming no previous record exists - script will proceed" "WARNING" | Out-Null
            return $null
        }
    }
}

# Function to determine if script should run based on storage table history
function Test-ShouldRunScript {
    param(
        [object]$LatestRecord,
        [string]$ComputerName
    )
    
    # If no record exists, script should run
    if ($null -eq $LatestRecord) {
        return $true
    }
    
    $imageHealthState = $LatestRecord.ImageHealthState
    $afterRepairStatus = $LatestRecord.AfterRepairStatus
    $imageRepaired = $LatestRecord.ImageRepaired
    
    # Condition 2: ImageHealthState does not equal Healthy AND AfterRepairStatus does not contain "Healthy" or "N/A"
    if ($imageHealthState -ne "Healthy" -and 
        $afterRepairStatus -notlike "*Healthy*" -and 
        $afterRepairStatus -ne "N/A") {
        return $true
    }
    
    # Condition 3: ImageHealthState equals "Repairable" and ImageRepaired equals False
    if ($imageHealthState -eq "Repairable" -and 
        ($imageRepaired -eq "False" -or $imageRepaired -eq $false)) {
        return $true
    }
    
    # Condition 4: AfterRepairStatus contains "Skipped - Users Logged On" (retry when users are no longer present)
    if ($afterRepairStatus -like "*Skipped - Users Logged On*") {
        return $true
    }
    
    # If none of the conditions are met, script should not run
    return $false
}

# Start logging
Write-Log "========================================" "INFO"
Write-Log "Windows Health Check Script Started" "INFO"
Write-Log "Log file: $LogFile" "INFO"
Write-Log "Script version: 0.9.5" "INFO"
Write-Log "========================================" "INFO"

Write-Log "Running Windows Image Health Check..." "INFO"

if ($UploadToStorageAccount) {
    Write-Log "Upload Policy: Upload results to Azure Storage Account" "INFO"
}
else {
    Write-Log "Upload Policy: Local processing only - no upload" "INFO"
}

# Check storage table history to determine if script should run (unless disabled by configuration)
$shouldSkipDueToHistory = $false
$historySkipReason = ""
$shouldRunBasedOnHistory = $null  # Initialize to ensure clean state

if ($SkipStorageTableCheck) {
    Write-Log "STORAGE TABLE CHECK DISABLED: SkipStorageTableCheck variable set to true" "WARNING"
    Write-Log "Script will proceed without checking previous execution history" "WARNING"
}
else {
    Write-Log "Checking storage table for previous execution history..." "INFO"
    $computerName = if ($env:COMPUTERNAME) { $env:COMPUTERNAME } else { "Unknown" }
    
    try {
        $latestRecord = Get-LatestTableRecord -StorageAccountName $StorageAccountName -StorageAccountKey $StorageAccountKey -TableName $TableName -ComputerName $computerName
        
        # Call the function and capture only the boolean result
        $shouldRunBasedOnHistory = $null
        # Check if we should run based on the latest record
        $shouldRunBasedOnHistory = Test-ShouldRunScript -LatestRecord $latestRecord -ComputerName $computerName
        
        if ($shouldRunBasedOnHistory) {
            if ($null -eq $latestRecord) {
                Write-Log "DECISION: Script will run - No previous record found for $computerName" "INFO"
            } else {
                $imageHealthState = if ($latestRecord.ImageHealthState) { $latestRecord.ImageHealthState } else { "Unknown" }
                $afterRepairStatus = if ($latestRecord.AfterRepairStatus) { $latestRecord.AfterRepairStatus } else { "Unknown" }
                $previousImageRepaired = if ($latestRecord.ImageRepaired) { $latestRecord.ImageRepaired } else { "Unknown" }
                
                Write-Log "Evaluating latest record - ImageHealthState: '$imageHealthState', AfterRepairStatus: '$afterRepairStatus', ImageRepaired: '$previousImageRepaired'" "INFO"
                
                if ($imageHealthState -ne "Healthy" -and 
                    $afterRepairStatus -notlike "*Healthy*" -and 
                    $afterRepairStatus -ne "N/A") {
                    Write-Log "DECISION: Script will run - ImageHealthState is '$imageHealthState' (not Healthy) AND AfterRepairStatus '$afterRepairStatus' does not contain 'Healthy' or 'N/A'" "INFO"
                } elseif ($imageHealthState -eq "Repairable" -and 
                    ($previousImageRepaired -eq "False" -or $previousImageRepaired -eq $false)) {
                    Write-Log "DECISION: Script will run - ImageHealthState is 'Repairable' AND ImageRepaired is 'False'" "INFO"
                } elseif ($afterRepairStatus -like "*Skipped - Users Logged On*") {
                    Write-Log "DECISION: Script will run - Previous execution was skipped due to logged-on users, retrying" "INFO"
                }
            }
        } else {
            Write-Log "DECISION: Script will NOT run - Latest record shows healthy state or successful repair" "INFO"
            if ($null -ne $latestRecord) {
                $imageHealthState = if ($latestRecord.ImageHealthState) { $latestRecord.ImageHealthState } else { "Unknown" }
                $afterRepairStatus = if ($latestRecord.AfterRepairStatus) { $latestRecord.AfterRepairStatus } else { "Unknown" }
                $previousImageRepaired = if ($latestRecord.ImageRepaired) { $latestRecord.ImageRepaired } else { "Unknown" }
                
                Write-Log "  ImageHealthState: '$imageHealthState'" "INFO"
                Write-Log "  AfterRepairStatus: '$afterRepairStatus'" "INFO"
                Write-Log "  ImageRepaired: '$previousImageRepaired'" "INFO"
            }
            $shouldSkipDueToHistory = $true
        }
        
        # If we didn't get a boolean, something went wrong - default to true (run) for safety when checking history
        if ($null -eq $shouldRunBasedOnHistory -or $shouldRunBasedOnHistory -isnot [bool]) {
            Write-Log "ERROR: Test-ShouldRunScript did not return a valid boolean. Defaulting to run execution for safety." "ERROR"
            $shouldRunBasedOnHistory = $true  # Changed from false to true for safety
        }
        
        if ($shouldRunBasedOnHistory -eq $false) {
            $shouldSkipDueToHistory = $true
            
            # Provide more specific skip reason based on the actual scenario

            if ($null -eq $latestRecord) {
                $historySkipReason = "Logic error: No previous record exists"                
            } else {
                $imageHealthState = if ($latestRecord.ImageHealthState) { $latestRecord.ImageHealthState } else { "Unknown" }
                $afterRepairStatus = if ($latestRecord.AfterRepairStatus) { $latestRecord.AfterRepairStatus } else { "Unknown" }
                $previousImageRepaired = if ($latestRecord.ImageRepaired) { $latestRecord.ImageRepaired } else { "Unknown" }
                
                if ($imageHealthState -eq "Healthy" -and $afterRepairStatus -like "*Healthy*") {
                    $historySkipReason = "Healthy state - no further action needed"
                } elseif ($imageHealthState -eq "Repairable" -and $previousImageRepaired -eq "True") {
                    $historySkipReason = "Previous execution successfully repaired the image - no action needed"
                } else {
                    $historySkipReason = "Previous execution analysis indicates no action needed (Health: $imageHealthState, Repair: $afterRepairStatus)"
                }
            }
            
            Write-Log "SKIPPING SCRIPT EXECUTION: $historySkipReason" "WARNING"
        }
        elseif ($shouldRunBasedOnHistory -eq $true) {
            $shouldSkipDueToHistory = $false
            Write-Log "Storage table check completed - script will proceed based on history evaluation" "INFO"
        }
    }
    catch {
        Write-Log "Storage table check failed: $($_.Exception.Message)" "ERROR"
        Write-Log "Proceeding with script execution due to check failure" "WARNING"
    }
}

# Check for active logged-on users before proceeding (unless disabled by configuration)
if ($shouldSkipDueToHistory) {
    # Skip due to storage table history
    Write-Log "OPERATIONS SKIPPED: $historySkipReason" "WARNING"
    
    # Initialize variables for upload (all skipped due to history)
    $imageHealthResult = @{
        ImageHealthState = "Skipped - Previous Healthy State"
        RestartNeeded = $false
    }
    $imageRepaired = $false
    $afterRepairStatus = "Skipped - Previous Healthy State"
    $updatesInstalled = @()
    $updatesFound = @()
    $updatesFailed = @()
    $rebootRequired = $false
    $loggedOnUsers = @()  # Set for consistency
    
    # Set skip reason for upload
    $skipReason = $historySkipReason
    $shouldSkipOperations = $true
}
elseif ($SkipUserSessionCheck) {
    Write-Log "USER SESSION CHECK DISABLED: SkipUserSessionCheck variable set to true" "WARNING"
    Write-Log "Script will proceed with operations regardless of active user sessions" "WARNING"
    
    # Set empty user list for consistency
    $loggedOnUsers = @()
    $shouldSkipOperations = $false
}
else {
    Write-Log "Checking for active logged-on user sessions..." "INFO"
    $loggedOnUsers = Get-LoggedOnUsers
    Write-Log "Total unique users found: $($loggedOnUsers.Count)" "INFO"

    if ($loggedOnUsers.Count -gt 0) {
        # Users are logged on - either wait or skip based on configuration
        $userList = $loggedOnUsers -join ", "
        
        if ($WaitForUsersToLogOff) {
            Write-Log "WAITING FOR USER LOGOFF: Active or disconnected user sessions detected" "WARNING"
            Write-Log "Logged-on users: $userList" "WARNING"
            Write-Log "WaitForUsersToLogOff is enabled - will wait and retry up to $MaxRetryAttempts times (waiting $WaitRetryIntervalMinutes minutes between attempts)" "INFO"
            
            # Log detailed information about each user
            foreach ($user in $loggedOnUsers) {
                Write-Log "User Session Details: Username=$user" "INFO"
            }
            
            $attemptCount = 0
            $usersStillLoggedOn = $true
            $loggedOnUsersAfterWait = $loggedOnUsers
            
            # Retry loop - attempt up to MaxRetryAttempts times
            while ($usersStillLoggedOn -and $attemptCount -lt $MaxRetryAttempts) {
                $attemptCount++
                
                # Wait for the specified interval
                $waitSeconds = $WaitRetryIntervalMinutes * 60
                Write-Log "Attempt $attemptCount of $MaxRetryAttempts - Sleeping for $WaitRetryIntervalMinutes minutes ($waitSeconds seconds) before rechecking user sessions..." "INFO"
                Start-Sleep -Seconds $waitSeconds
                
                # Recheck for logged-on users
                Write-Log "Attempt $attemptCount - Rechecking for active logged-on user sessions after wait period..." "INFO"
                $loggedOnUsersAfterWait = Get-LoggedOnUsers
                Write-Log "Attempt $attemptCount - Total unique users found after wait: $($loggedOnUsersAfterWait.Count)" "INFO"
                
                if ($loggedOnUsersAfterWait.Count -eq 0) {
                    # No users logged on - can proceed
                    $usersStillLoggedOn = $false
                    Write-Log "SUCCESS: No users logged on after attempt $attemptCount - proceeding with health checks" "INFO"
                }
                else {
                    # Users still logged on
                    $userListAfterWait = $loggedOnUsersAfterWait -join ", "
                    if ($attemptCount -lt $MaxRetryAttempts) {
                        Write-Log "Attempt $attemptCount - Users still logged on, will retry: $userListAfterWait" "WARNING"
                    }
                    else {
                        Write-Log "Attempt $attemptCount - Users still logged on after all retry attempts: $userListAfterWait" "WARNING"
                    }
                }
            }
            
            if ($usersStillLoggedOn) {
                # Users still logged on after all retry attempts - skip operations
                $userListAfterWait = $loggedOnUsersAfterWait -join ", "
                Write-Log "SKIPPING SCRIPT EXECUTION: Users still logged on after $MaxRetryAttempts retry attempts" "WARNING"
                Write-Log "Users still logged on: $userListAfterWait" "WARNING"
                Write-Log "Script will not perform health checks, repairs, or updates while users remain active or disconnected" "WARNING"
                
                # Initialize variables for upload (all skipped)
                $imageHealthResult = @{
                    ImageHealthState = "Skipped - Users Still Logged On After $MaxRetryAttempts Retries"
                    RestartNeeded = $false
                }
                $imageRepaired = $false
                $afterRepairStatus = "Skipped - Users Still Logged On After $MaxRetryAttempts Retries"
                $updatesInstalled = @()
                $updatesFound = @()
                $updatesFailed = @()
                $rebootRequired = $false
                
                # Set skip reason for upload
                $skipReason = "Users still logged on after $MaxRetryAttempts retry attempts (${WaitRetryIntervalMinutes}min intervals): $userListAfterWait"
                
                # Update logged on users list for reporting
                $loggedOnUsers = $loggedOnUsersAfterWait
                
                # Jump to upload section
                $shouldSkipOperations = $true
            }
            else {
                # No users logged on after wait/retry - proceed with operations
                Write-Log "SUCCESS: No users logged on after wait/retry process - proceeding with health checks" "INFO"
                $loggedOnUsers = @()  # Clear the user list
                $shouldSkipOperations = $false
                $skipReason = $null  # Clear any previous skip reason
            }
        }
        else {
            # WaitForUsersToLogOff is disabled - skip immediately
            Write-Log "SKIPPING SCRIPT EXECUTION: Active or disconnected user sessions detected" "WARNING"
            Write-Log "Logged-on users: $userList" "WARNING"
            Write-Log "Script will not perform health checks, repairs, or updates while users are active or disconnected" "WARNING"
            Write-Log "WaitForUsersToLogOff is disabled - not waiting for users to log off" "INFO"
            
            # Log detailed information about each user
            foreach ($user in $loggedOnUsers) {
                Write-Log "User Session Details: Username=$user" "INFO"
            }
            
            # Initialize variables for upload (all skipped)
            $imageHealthResult = @{
                ImageHealthState = "Skipped - Users Logged On"
                RestartNeeded = $false
            }
            $imageRepaired = $false
            $afterRepairStatus = "Skipped - Users Logged On"
            $updatesInstalled = @()
            $updatesFound = @()
            $updatesFailed = @()
            $rebootRequired = $false
            
            # Set skip reason for upload
            $skipReason = "Active or disconnected user sessions detected: $userList"
            
            # Jump to upload section
            $shouldSkipOperations = $true
        }
    }
    else {
        Write-Log "No active or disconnected user sessions detected - proceeding with health checks" "INFO"
        $shouldSkipOperations = $false
        $skipReason = $null  # Clear any previous skip reason
    }
}

if (-not $shouldSkipOperations) {

# Run health check
Write-Log "Running Windows Image Health Scan..." "INFO"
try {
    $imageHealthResult = Repair-WindowsImage -Online -ScanHealth -ErrorAction Stop
    
    if (!$imageHealthResult) {
        Write-Log "Warning: Image health scan returned null result" "WARNING"
        $imageHealthResult = @{
            ImageHealthState = "ScanFailed"
            RestartNeeded = $false
        }
    }
    elseif ($null -eq $imageHealthResult.ImageHealthState.ToString() -or $imageHealthResult.ImageHealthState.ToString() -eq "") {
        Write-Log "Warning: Image health state is null or empty" "WARNING"
        $imageHealthResult.ImageHealthState = "Unknown"
    }
    
    Write-Log "Health check completed: $($imageHealthResult.ImageHealthState.ToString())" "INFO"
}
catch {
    Write-Log "Error: Image health scan failed: $($_.Exception.Message)" "ERROR"
    $imageHealthResult = @{
        ImageHealthState = "ScanFailed"
        RestartNeeded = $false
    }
    Write-Log "Using fallback health state: ScanFailed" "WARNING"
}

# If image health is Repairable, run RestoreHealth
if ($imageHealthResult.ImageHealthState -eq "Repairable") {
    Write-Log "Image is repairable. Running Repair-WindowsImage -Online -RestoreHealth..." "INFO"
    try {
        $repairResult = Repair-WindowsImage -Online -RestoreHealth -ErrorAction Stop
        Write-Log "Image repair operation completed" "INFO"
        Write-Log "Repair result - ImageHealthState: $($repairResult.ImageHealthState), RestartNeeded: $($repairResult.RestartNeeded)" "INFO"
        $imageRepaired = $true
        
        # Run a post-repair health check to verify the repair was successful
        Write-Log "Running post-repair health check..." "INFO"
        try {
            $afterRepairResult = Repair-WindowsImage -Online -ScanHealth -ErrorAction Stop
            $afterRepairStatus = $afterRepairResult.ImageHealthState
            Write-Log "Post-repair health check result: $afterRepairStatus" "INFO"
            
            if ($afterRepairStatus -eq "Healthy") {
                Write-Log "Image repair was successful - system is now healthy" "INFO"
            } elseif ($afterRepairStatus -eq "Repairable") {
                Write-Log "Warning: Image still shows as repairable after repair attempt" "WARNING"
            } else {
                Write-Log "Warning: Post-repair status is: $afterRepairStatus" "WARNING"
            }
        }
        catch {
            Write-Log "Post-repair health check failed: $($_.Exception.Message)" "ERROR"
            $afterRepairStatus = "PostRepairCheckFailed"
        }
    }
    catch {
        Write-Log "Image repair failed: $($_.Exception.Message)" "ERROR"
        $imageRepaired = $false
        $afterRepairStatus = "RepairFailed"
    }
} else {
    # If image is not repairable, set the after repair status to the original health state
    if ($imageHealthResult.ImageHealthState -eq "Healthy") {
        $afterRepairStatus = "Healthy - No Repair Needed"
        Write-Log "Image is already healthy - no repair needed" "INFO"
    } else {
        $afterRepairStatus = "No Repair Attempted - Status: $($imageHealthResult.ImageHealthState)"
        Write-Log "Image status is $($imageHealthResult.ImageHealthState) - no repair attempted" "INFO"
    }
}

# Run Windows Update using native COM objects
Write-Log "Checking for Windows Updates..." "INFO"
try {
    # Create Windows Update session
    $UpdateSession = New-Object -ComObject Microsoft.Update.Session
    $UpdateSearcher = $UpdateSession.CreateUpdateSearcher()
    
    Write-Output "Searching for available updates..."
    # Search for all non-hidden, non-installed updates (includes cumulative updates, security updates, etc.)
    # This broader search will catch cumulative updates that might be categorized differently
    $SearchResult = $UpdateSearcher.Search("IsInstalled=0 and IsHidden=0")
    
    Write-Output "Found $($SearchResult.Updates.Count) total updates to evaluate"
    
    if ($SearchResult.Updates.Count -gt 0) {
        Write-Output "Found $($SearchResult.Updates.Count) available updates"
        
        # Debug: List all found updates before filtering
        Write-Output "DEBUG: All updates found in search:"
        foreach ($Update in $SearchResult.Updates) {
            Write-Output "  DEBUG: $($Update.Title)"
        }
        Write-Output "" # Empty line for readability
        
        # Create update collection for download/install
        $UpdatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl
        
        foreach ($Update in $SearchResult.Updates) {
            # Track all updates found for reporting
            $kbNumber = ""
            if ($Update.Title -match "KB\d+") {
                $kbNumber = $matches[0]
            }
            
            $updatesFound += @{
                Title = $Update.Title
                KB = $kbNumber
                Size = [math]::Round($Update.MaxDownloadSize / 1MB, 2)
                IsDriver = $false  # Will be updated below if it's a driver
            }
            
            # Filter out driver updates but keep everything else (including cumulative updates)
            $isDriverUpdate = $false
                  
            foreach ($category in $Update.Categories) {
                if ($category.Name -like "*Driver*" -or $category.CategoryID -eq "ebfc1fc5-71a4-4f7b-9aca-3b9a503104a0") {
                    $isDriverUpdate = $true
                    # Mark this update as a driver in our tracking array
                    $updatesFound[-1].IsDriver = $true
                    break
                }
            }
            
            # Special handling for .NET Framework and Security platform updates
            $updateTitle = $Update.Title  
            
            if ($updateTitle -like "*.NET Framework*" -or 
                $updateTitle -like "*Windows Security platform*" -or
                $updateTitle -like "*Cumulative Update*" -or
                $updateTitle -match "KB\d{7}" -or
                $updateTitle -like "*Security Update*" -or
                $updateTitle -like "*Critical Update*" -or
                $updateTitle -like "*Quality Update*" -or
                $updateTitle -like "*Monthly Rollup*") {
                $isSpecialUpdate = $true
            }
            
            # Don't skip drivers, but be more inclusive for important updates
            if (-not $isDriverUpdate) {
                if ($Update.EulaAccepted -eq $false) {
                    $Update.AcceptEula()
                }
                $UpdatesToInstall.Add($Update) | Out-Null
                
                # Show update type for debugging
                $updateType = "Other"
                
                # Enhanced detection for different update types
                if ($updateTitle -match "Cumulative|KB\d{7}" -or $updateTitle -like "*Monthly Rollup*" -or $updateTitle -like "*Quality Update*") {
                    $updateType = "Cumulative"
                }
                elseif ($updateTitle -like "*.NET Framework*") {
                    $updateType = ".NET Framework"
                }
                elseif ($updateTitle -like "*Windows Security platform*" -or $updateTitle -like "*Security Update*" -or $updateTitle -like "*Defender*") {
                    $updateType = "Security"  
                }
                elseif ($updateTitle -like "*Critical*" -or $updateTitle -like "*Important*") {
                    $updateType = "Critical"
                }
                elseif ($updateTitle -like "*Optional*" -or $updateTitle -like "*Preview*") {
                    $updateType = "Optional"
                }
                
                # Also check categories for better classification
                foreach ($category in $Update.Categories) {
                    $categoryName = $category.Name
                    if ($categoryName -like "*Updates*" -and ($updateTitle -like "*Cumulative*" -or $updateTitle -match "KB\d{7}")) {
                        $updateType = "Cumulative"
                        break
                    }
                    elseif ($categoryName -like "*Security*") {
                        $updateType = "Security"
                        break
                    }
                    elseif ($categoryName -like "*.NET*" -or $categoryName -like "*Framework*") {
                        $updateType = ".NET Framework"
                        break
                    }
                }
                
                Write-Output "  - [$updateType] $($Update.Title)"
            }
            else {
                Write-Output "  - [SKIPPED - Driver] $($Update.Title)"
            }
        }
        
        Write-Output "Updates added to collection: $($UpdatesToInstall.Count)"
        
        if ($UpdatesToInstall.Count -gt 0) {
            Write-Output "Downloading updates..."
            
            # Download updates
            $Downloader = $UpdateSession.CreateUpdateDownloader()
            $Downloader.Updates = $UpdatesToInstall
            $DownloadResult = $Downloader.Download()
            
            Write-Output "Download result code: $($DownloadResult.ResultCode)"
            
            if ($DownloadResult.ResultCode -eq 2) {
                # OperationResultCodeSucceeded
                Write-Output "Download completed successfully. Installing updates..."
                
                # Install updates
                $Installer = $UpdateSession.CreateUpdateInstaller()
                $Installer.Updates = $UpdatesToInstall
                Write-Output "Starting installation of $($UpdatesToInstall.Count) updates..."
                $InstallationResult = $Installer.Install()
                
                Write-Output "Installation result code: $($InstallationResult.ResultCode)"
                
                # Track installed updates
                for ($i = 0; $i -lt $UpdatesToInstall.Count; $i++) {
                    $update = $UpdatesToInstall.Item($i)
                    $updateResult = $InstallationResult.GetUpdateResult($i)
                    
                    Write-Output "Update $($i+1): $($update.Title) - Result: $($updateResult.ResultCode)"
                    
                    # Extract KB number from title if available
                    $kbNumber = ""
                    if ($update.Title -match "KB\d+") {
                        $kbNumber = $matches[0]
                    }
                    
                    $updatesInstalled += @{
                        Title          = $update.Title
                        KB             = $kbNumber
                        Size           = [math]::Round($update.MaxDownloadSize / 1MB, 2)
                        ResultCode     = $updateResult.ResultCode
                        Status         = switch ($updateResult.ResultCode) {
                            0 { "NotStarted" }
                            1 { "InProgress" }
                            2 { "Succeeded" }
                            3 { "SucceededWithErrors" }
                            4 { "Failed" }
                            5 { "Aborted" }
                            default { "Unknown" }
                        }
                        RebootRequired = $updateResult.RebootRequired
                    }
                }
                
                # Check if any update requires reboot
                $rebootRequired = $InstallationResult.RebootRequired -or ($updatesInstalled | Where-Object { $_.RebootRequired } | Measure-Object).Count -gt 0
                
                Write-Output "Installed $($updatesInstalled.Count) updates"
                Write-Output "Installation result code: $($InstallationResult.ResultCode)"
                Write-Output "Reboot required: $rebootRequired"
            }
            else {
                Write-Output "Download failed with result code: $($DownloadResult.ResultCode)"
                
                # Track all updates that failed to download
                for ($i = 0; $i -lt $UpdatesToInstall.Count; $i++) {
                    $update = $UpdatesToInstall.Item($i)
                    
                    # Extract KB number from title if available
                    $kbNumber = ""
                    if ($update.Title -match "KB\d+") {
                        $kbNumber = $matches[0]
                    }
                    
                    $updatesFailed += @{
                        Title = $update.Title
                        KB = $kbNumber
                        Size = [math]::Round($update.MaxDownloadSize / 1MB, 2)
                        FailureReason = "Download failed with result code: $($DownloadResult.ResultCode)"
                        FailureStage = "Download"
                    }
                }
            }
        }
        else {
            Write-Output "Warning: No updates were added to the installation collection"
            Write-Output "This might indicate an issue with update collection or permissions"
            
            # Try alternative approach - install updates individually
            Write-Output "Attempting to install updates individually..."
            
            foreach ($Update in $SearchResult.Updates) {
                try {
                    Write-Output "Processing: $($Update.Title)"
                    
                    if ($Update.EulaAccepted -eq $false) {
                        $Update.AcceptEula()
                    }
                    
                    # Create individual collection
                    $IndividualCollection = New-Object -ComObject Microsoft.Update.UpdateColl
                    $IndividualCollection.Add($Update) | Out-Null
                    
                    # Download individual update
                    $IndividualDownloader = $UpdateSession.CreateUpdateDownloader()
                    $IndividualDownloader.Updates = $IndividualCollection
                    $IndividualDownloadResult = $IndividualDownloader.Download()
                    
                    if ($IndividualDownloadResult.ResultCode -eq 2) {
                        # Install individual update
                        $IndividualInstaller = $UpdateSession.CreateUpdateInstaller()
                        $IndividualInstaller.Updates = $IndividualCollection
                        $IndividualInstallResult = $IndividualInstaller.Install()
                        
                        # Extract KB number from title if available
                        $kbNumber = ""
                        if ($Update.Title -match "KB\d+") {
                            $kbNumber = $matches[0]
                        }
                        
                        $updatesInstalled += @{
                            Title          = $Update.Title
                            KB             = $kbNumber
                            Size           = [math]::Round($Update.MaxDownloadSize / 1MB, 2)
                            ResultCode     = $IndividualInstallResult.ResultCode
                            Status         = switch ($IndividualInstallResult.ResultCode) {
                                0 { "NotStarted" }
                                1 { "InProgress" }
                                2 { "Succeeded" }
                                3 { "SucceededWithErrors" }
                                4 { "Failed" }
                                5 { "Aborted" }
                                default { "Unknown" }
                            }
                            RebootRequired = $IndividualInstallResult.RebootRequired
                        }
                        
                        Write-Output "  Installed: $($Update.Title) - Result: $($IndividualInstallResult.ResultCode)"
                        
                        if ($IndividualInstallResult.RebootRequired) {
                            $rebootRequired = $true
                        }
                    }
                    else {
                        Write-Output "  Download failed for: $($Update.Title)"
                        
                        # Track individual download failure
                        $kbNumber = ""
                        if ($Update.Title -match "KB\d+") {
                            $kbNumber = $matches[0]
                        }
                        
                        $updatesFailed += @{
                            Title = $Update.Title
                            KB = $kbNumber
                            Size = [math]::Round($Update.MaxDownloadSize / 1MB, 2)
                            FailureReason = "Individual download failed with result code: $($IndividualDownloadResult.ResultCode)"
                            FailureStage = "Individual Download"
                        }
                    }
                }
                catch {
                    Write-Log "  Error processing update $($Update.Title): $($_.Exception.Message)" "ERROR"
                    
                    # Track individual processing failure
                    $kbNumber = ""
                    if ($Update.Title -match "KB\d+") {
                        $kbNumber = $matches[0]
                    }
                    
                    $updatesFailed += @{
                        Title = $Update.Title
                        KB = $kbNumber
                        Size = if ($Update.MaxDownloadSize) { [math]::Round($Update.MaxDownloadSize / 1MB, 2) } else { 0 }
                        FailureReason = "Processing error: $($_.Exception.Message)"
                        FailureStage = "Individual Processing"
                    }
                }
            }
            
            Write-Output "Individual installation completed. Total updates processed: $($updatesInstalled.Count)"
        }
    }
    else {
        Write-Output "No updates available"
    }
}
catch {
    Write-Log "Windows Update check/install failed: $($_.Exception.Message)" "ERROR"
    
    # Track general Windows Update failure
    $updatesFailed += @{
        Title = "Windows Update Process"
        KB = "N/A"
        Size = 0
        FailureReason = "Windows Update check/install failed: $($_.Exception.Message)"
        FailureStage = "Windows Update Process"
    }
}

} # End of if (-not $shouldSkipOperations) block

# Determine if we should upload based on configuration
$shouldUpload = $UploadToStorageAccount

# Set upload reason based on whether operations were skipped
if ($null -ne $skipReason) {
    $uploadReason = $skipReason
}
elseif ($SkipUserSessionCheck) {
    $uploadReason = "User session check disabled - manual configuration override"
}
else {
    $uploadReason = if ($UploadToStorageAccount) { 
        "Upload to storage account enabled" 
    } else { 
        "Upload to storage account disabled" 
    }
}

if ($shouldUpload) {
    Write-Output "Upload Decision: $uploadReason"
}
else {
    Write-Output "Upload Decision: $uploadReason"
}

if ($shouldUpload) {
    # Insert entity into existing table
    try {
        # Use alternative method for date in constrained environments
        $currentDate = Get-Date -ErrorAction SilentlyContinue
        if ($null -eq $currentDate) {
            $currentDate = [System.DateTime]::Now
        }
        
        $date = $currentDate.ToUniversalTime().ToString("R")
        
        # Generate a safer RowKey
        $computerName = if ($env:COMPUTERNAME) { $env:COMPUTERNAME } else { "Unknown" }
        $timestamp = $currentDate.ToString('yyyyMMdd-HHmmss')
        $rowKey = "$computerName-$timestamp"
        
        # Convert updates to JSON string for storage with error handling
        $updatesJson = "[]"
        if ($updatesInstalled.Count -gt 0) {
            try {
                $updatesJson = ($updatesInstalled | ConvertTo-Json -Compress -ErrorAction Stop)
            }
            catch {
                Write-Log "Warning: Failed to convert updates to JSON, using empty array" "WARNING"
                $updatesJson = "[]"
            }
        }
        
        # Convert updates found to JSON string for storage
        $updatesFoundJson = "[]"
        if ($updatesFound.Count -gt 0) {
            try {
                $updatesFoundJson = ($updatesFound | ConvertTo-Json -Compress -ErrorAction Stop)
            }
            catch {
                Write-Log "Warning: Failed to convert updates found to JSON, using empty array" "WARNING"
                $updatesFoundJson = "[]"
            }
        }
        
        # Convert update failures to JSON string for storage
        $updatesFailedJson = "[]"
        if ($updatesFailed.Count -gt 0) {
            try {
                $updatesFailedJson = ($updatesFailed | ConvertTo-Json -Compress -ErrorAction Stop)
            }
            catch {
                Write-Log "Warning: Failed to convert update failures to JSON, using empty array" "WARNING"
                $updatesFailedJson = "[]"
            }
        }
        
        # Create entity hashtable with null-safe property access
        $entityData = @{
            PartitionKey     = "WindowsHealth"
            RowKey           = $rowKey
            ComputerName     = $computerName
            ImageHealthState = if ($imageHealthResult -and $null -ne $imageHealthResult.ImageHealthState) { 
                                   $imageHealthResult.ImageHealthState.ToString() 
                               } else { 
                                   "Unknown" 
                               }
            RestartNeeded    = if ($imageHealthResult -and $null -ne $imageHealthResult.RestartNeeded) { 
                                   $imageHealthResult.RestartNeeded.ToString() 
                               } else { 
                                   "False" 
                               }
            CheckDateTime    = $currentDate.ToString('yyyy-MM-dd HH:mm:ss')
            UploadReason     = if ($uploadReason) { $uploadReason } else { "Unknown" }
            ImageRepaired    = if ($null -ne $imageRepaired) { $imageRepaired.ToString() } else { "False" }
            AfterRepairStatus = if ($afterRepairStatus) { $afterRepairStatus } else { "N/A" }
            LoggedOnUsers    = if ($null -ne $loggedOnUsers -and $loggedOnUsers.Count -gt 0) { 
                                   $loggedOnUsers -join ", "
                               } else { 
                                   "None" 
                               }
            UpdatesInstalled = $updatesJson
            UpdatesCount     = if ($null -ne $updatesInstalled) { $updatesInstalled.Count } else { 0 }
            UpdatesFound     = $updatesFoundJson
            UpdatesFoundCount = if ($null -ne $updatesFound) { $updatesFound.Count } else { 0 }
            UpdatesFailed    = $updatesFailedJson
            UpdatesFailedCount = if ($null -ne $updatesFailed) { $updatesFailed.Count } else { 0 }
            RebootRequired   = if ($null -ne $rebootRequired) { $rebootRequired.ToString() } else { "False" }
        }
        
        # Debug: Log the ImageHealthState value before upload
        Write-Log "DEBUG: imageHealthResult object type: $($imageHealthResult.GetType().Name)" "DEBUG"
        Write-Log "DEBUG: imageHealthResult.ImageHealthState value: '$($imageHealthResult.ImageHealthState)'" "DEBUG"
        Write-Log "DEBUG: imageHealthResult.ImageHealthState type: $($imageHealthResult.ImageHealthState.GetType().Name)" "DEBUG"
        Write-Log "DEBUG: Entity ImageHealthState will be: '$($entityData.ImageHealthState)'" "DEBUG"
        Write-Log "DEBUG: imageRepaired variable type: $($imageRepaired.GetType().Name)" "DEBUG"
        Write-Log "DEBUG: imageRepaired variable value: '$imageRepaired'" "DEBUG"
        Write-Log "DEBUG: Entity ImageRepaired will be: '$($entityData.ImageRepaired)'" "DEBUG"
        
        # Convert to JSON with error handling
        $entity = $null
        try {
            $entity = $entityData | ConvertTo-Json -ErrorAction Stop
        }
        catch {
            Write-Log "Error: Failed to convert entity to JSON: $($_.Exception.Message)" "ERROR"
            Write-Log "Attempting manual JSON creation..." "WARNING"
            
            # Manual JSON creation as fallback
            $entity = @"
{
    "PartitionKey": "$($entityData.PartitionKey)",
    "RowKey": "$($entityData.RowKey)",
    "ComputerName": "$($entityData.ComputerName)",
    "ImageHealthState": "$($entityData.ImageHealthState)",
    "RestartNeeded": "$($entityData.RestartNeeded)",
    "CheckDateTime": "$($entityData.CheckDateTime)",
    "UploadReason": "$($entityData.UploadReason)",
    "ImageRepaired": "$($entityData.ImageRepaired)",
    "AfterRepairStatus": "$($entityData.AfterRepairStatus)",
    "LoggedOnUsers": "$($entityData.LoggedOnUsers)",
    "UpdatesInstalled": $($entityData.UpdatesInstalled),
    "UpdatesCount": $($entityData.UpdatesCount),
    "UpdatesFound": $($entityData.UpdatesFound),
    "UpdatesFoundCount": $($entityData.UpdatesFoundCount),
    "UpdatesFailed": $($entityData.UpdatesFailed),
    "UpdatesFailedCount": $($entityData.UpdatesFailedCount),
    "RebootRequired": "$($entityData.RebootRequired)"
}
"@
        }
        
        # Validate entity is not null
        if ($null -eq $entity -or $entity.Length -eq 0) {
            throw "Entity JSON is null or empty"
        }
        
        # Calculate content length safely
        $contentLength = 0
        try {
            $contentLength = [System.Text.Encoding]::UTF8.GetByteCount($entity)
        }
        catch {
            Write-Log "Warning: Failed to calculate content length, using string length" "WARNING"
            $contentLength = $entity.Length
        }

        $headers = @{
            "x-ms-date"     = $date
            "x-ms-version"  = "2019-02-02"
            "Accept"        = "application/json;odata=nometadata"
            "Content-Type"  = "application/json"
            "Authorization" = New-TableAuthHeader $StorageAccountName $StorageAccountKey "POST" "/$TableName" $date
        }

        Write-Output "Uploading to table: $TableName"
        Write-Output "Date: $date"

        $VerbosePreference = "Continue"

        try {
            $response = Invoke-RestMethod -Uri "https://$StorageAccountName.table.core.windows.net/$TableName" -Method POST -Headers $headers -Body $entity -ContentType "application/json" -Verbose
            
            # Safe property access for logging
            $healthState = if ($imageHealthResult -and $null -ne $imageHealthResult.ImageHealthState) { 
                               $imageHealthResult.ImageHealthState.ToString() 
                           } else { 
                               "Unknown" 
                           }
            $restartNeeded = if ($imageHealthResult -and $null -ne $imageHealthResult.RestartNeeded) { 
                                 $imageHealthResult.RestartNeeded.ToString() 
                             } else { 
                                 "False" 
                             }
            $updatesFoundCount = if ($null -ne $updatesFound) { $updatesFound.Count } else { 0 }
            $updatesInstalledCount = if ($null -ne $updatesInstalled) { $updatesInstalled.Count } else { 0 }
            $updatesFailedCount = if ($null -ne $updatesFailed) { $updatesFailed.Count } else { 0 }
            $repairStatus = if ($afterRepairStatus) { $afterRepairStatus } else { "N/A" }
            $rebootReq = if ($null -ne $rebootRequired) { $rebootRequired.ToString() } else { "False" }
            $imageRepairedStr = if ($null -ne $imageRepaired) { $imageRepaired.ToString() } else { "False" }
            
            Write-Log "UPLOAD SUCCESS: Health: $healthState, Restart: $restartNeeded, Updates Found: $updatesFoundCount, Updates Installed: $updatesInstalledCount, Updates Failed: $updatesFailedCount, Image Repaired: $imageRepairedStr, After Repair Status: $repairStatus, Reboot Required: $rebootReq" "INFO"
        }
        catch {
            Write-Log "UPLOAD FAILED" "ERROR"
            Write-Log "Error Details:" "ERROR"
            
            if ($_.Exception.Response) {
                Write-Log "Status Code: $($_.Exception.Response.StatusCode)" "ERROR"
                Write-Log "Status Description: $($_.Exception.Response.StatusDescription)" "ERROR"
            }
            
            Write-Log "Full Error: $($_.Exception.Message)" "ERROR"
            
            if ($_.Exception.Response) {
                try {
                    $streamReader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                    $responseBody = $streamReader.ReadToEnd()
                    Write-Log "Response Body: $responseBody" "ERROR"
                    $streamReader.Close()
                }
                catch {
                    Write-Log "Could not read response body" "WARNING"
                }
            }
        }
    }
    catch {
        Write-Log "UPLOAD PREPARATION FAILED: $($_.Exception.Message)" "ERROR"
        Write-Log "Continuing with script execution..." "WARNING"
    }
}
else {
    # Safe property access for skipped upload logging
    $healthState = if ($imageHealthResult -and $null -ne $imageHealthResult.ImageHealthState) { 
                       $imageHealthResult.ImageHealthState.ToString() 
                   } else { 
                       "Unknown" 
                   }
    $restartNeeded = if ($imageHealthResult -and $null -ne $imageHealthResult.RestartNeeded) { 
                         $imageHealthResult.RestartNeeded.ToString() 
                     } else { 
                         "False" 
                     }
    $updatesFoundCount = if ($null -ne $updatesFound) { $updatesFound.Count } else { 0 }
    $updatesInstalledCount = if ($null -ne $updatesInstalled) { $updatesInstalled.Count } else { 0 }
    $updatesFailedCount = if ($null -ne $updatesFailed) { $updatesFailed.Count } else { 0 }
    $repairStatus = if ($afterRepairStatus) { $afterRepairStatus } else { "N/A" }
    $rebootReq = if ($null -ne $rebootRequired) { $rebootRequired.ToString() } else { "False" }
    $imageRepairedStr = if ($null -ne $imageRepaired) { $imageRepaired.ToString() } else { "False" }
    
    Write-Output "SKIPPED UPLOAD: Health: $healthState, Restart: $restartNeeded, Updates Found: $updatesFoundCount, Updates Installed: $updatesInstalledCount, Updates Failed: $updatesFailedCount, Image Repaired: $imageRepairedStr, After Repair Status: $repairStatus, Reboot Required: $rebootReq"
    Write-Output "Reason: $uploadReason"
}

Write-Output ""
Write-Output "Summary:"
Write-Output "  Computer: $(if ($env:COMPUTERNAME) { $env:COMPUTERNAME } else { 'Unknown' })"
Write-Output "  Health State: $(if ($imageHealthResult -and $null -ne $imageHealthResult.ImageHealthState) { $imageHealthResult.ImageHealthState.ToString() } else { 'Unknown' })"
Write-Output "  Restart Needed: $(if ($imageHealthResult -and $null -ne $imageHealthResult.RestartNeeded) { $imageHealthResult.RestartNeeded.ToString() } else { 'False' })"
Write-Output "  Image Repaired: $(if ($null -ne $imageRepaired) { $imageRepaired.ToString() } else { 'False' })"
Write-Output "  After Repair Status: $(if ($afterRepairStatus) { $afterRepairStatus } else { 'N/A' })"
Write-Output "  Updates Found: $(if ($null -ne $updatesFound) { $updatesFound.Count } else { 0 })"
Write-Output "  Updates Installed: $(if ($null -ne $updatesInstalled) { $updatesInstalled.Count } else { 0 })"
Write-Output "  Updates Failed: $(if ($null -ne $updatesFailed) { $updatesFailed.Count } else { 0 })"
Write-Output "  Reboot Required: $(if ($null -ne $rebootRequired) { $rebootRequired.ToString() } else { 'False' })"

if ($loggedOnUsers.Count -gt 0) {
    Write-Output "  Logged-On Users: $($loggedOnUsers -join ', ')"
} else {
    Write-Output "  Logged-On Users: None"
}

if ($shouldSkipOperations) {
    Write-Output "  Operations: Skipped due to active or disconnected users"
}

if ($UploadToStorageAccount) {
    Write-Output "  Upload Policy: Enabled"
} else {
    Write-Output "  Upload Policy: Disabled"
}

if ($shouldUpload) {
    Write-Output "  Action Taken: Uploaded to Azure"
}
else {
    Write-Output "  Action Taken: Local check only"
}

# Handle reboot if required
if ($rebootRequired) {
    Write-Log "Reboot required. Initiating system restart..." "WARNING"
    Write-Log "========================================" "INFO"
    Write-Log "Script execution completed - REBOOT PENDING" "INFO"
    Write-Log "========================================" "INFO"
    
    Restart-Computer -Force
}
else {
    Write-Log "========================================" "INFO"
    Write-Log "Script execution completed successfully" "INFO"
    Write-Log "========================================" "INFO"
}